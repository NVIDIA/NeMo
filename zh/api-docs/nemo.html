

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Core APIs &mdash; nemo 0.9.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="NeMo API" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> nemo
          

          
          </a>

          
            
            
              <div class="version">
                0.9.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">如何安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/intro.html">从这里开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="../training.html">快速训练</a></li>
<li class="toctree-l1"><a class="reference internal" href="../asr/intro.html">语音识别</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nlp/intro.html">自然语言处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tts/intro.html">语音合成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../collections/modules.html">NeMo Collections API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">NeMo API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Core APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-nemo.core.neural_types">neural_types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nemo.core.neural_modules">neural_modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nemo.core.neural_factory">neural_factory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pytorch">PyTorch 后端</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-nemo.backends.pytorch.actions">基本操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nemo.backends.pytorch.nm">写你自己的神经模块需要的类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nemo.backends.pytorch.module_wrapper">可训练模块的封装器</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">nemo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">NeMo API</a> &raquo;</li>
        
      <li>Core APIs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-docs/nemo.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-apis">
<h1>Core APIs<a class="headerlink" href="#core-apis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-nemo.core.neural_types">
<span id="neural-types"></span><h2>neural_types<a class="headerlink" href="#module-nemo.core.neural_types" title="Permalink to this headline">¶</a></h2>
<p>This module contains Tags, AxisTypes, NeuralTypes and NmTensors.
Every NmTensor is of a particular Neural Type.
Neural Modules’ input and output ports are also of Neural Type.</p>
<p>An exception will be raised when a NmTensor and input port where it goes are
of incompatible types.</p>
<dl class="class">
<dt id="nemo.core.neural_types.BaseTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">BaseTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#BaseTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.BaseTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base Neural Tag. All Tags should inherit from this.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.BatchTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">BatchTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#BatchTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.BatchTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BaseTag" title="nemo.core.neural_types.BaseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BaseTag</span></code></a></p>
<p>Tag for batch dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.TimeTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">TimeTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#TimeTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.TimeTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BaseTag" title="nemo.core.neural_types.BaseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BaseTag</span></code></a></p>
<p>Tag for time dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.ProcessedTimeTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">ProcessedTimeTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#ProcessedTimeTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.ProcessedTimeTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.TimeTag" title="nemo.core.neural_types.TimeTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.TimeTag</span></code></a></p>
<p>Tag for processed time dimension.
For example: after pre-processing, or augmentation.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.ChannelTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">ChannelTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#ChannelTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.ChannelTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BaseTag" title="nemo.core.neural_types.BaseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BaseTag</span></code></a></p>
<p>Tag for channel dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.EmbeddedTextTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">EmbeddedTextTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#EmbeddedTextTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.EmbeddedTextTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.ChannelTag" title="nemo.core.neural_types.ChannelTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.ChannelTag</span></code></a></p>
<p>Tag for any dimensions that contains text that goes through an
enbedding layer.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.SpectrogramSignalTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">SpectrogramSignalTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#SpectrogramSignalTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.SpectrogramSignalTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.ChannelTag" title="nemo.core.neural_types.ChannelTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.ChannelTag</span></code></a></p>
<p>Tag for spectrogram signal dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.MelSpectrogramSignalTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">MelSpectrogramSignalTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#MelSpectrogramSignalTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.MelSpectrogramSignalTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.SpectrogramSignalTag" title="nemo.core.neural_types.SpectrogramSignalTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.SpectrogramSignalTag</span></code></a></p>
<p>Tag for mel spectrogram signal dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.MFCCSignalTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">MFCCSignalTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#MFCCSignalTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.MFCCSignalTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.SpectrogramSignalTag" title="nemo.core.neural_types.SpectrogramSignalTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.SpectrogramSignalTag</span></code></a></p>
<p>Tag for MFCC signal dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.EncodedRepresentationTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">EncodedRepresentationTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#EncodedRepresentationTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.EncodedRepresentationTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.ChannelTag" title="nemo.core.neural_types.ChannelTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.ChannelTag</span></code></a></p>
<p>Tag for encoded representation. This should be used to
denote encoders’ outputs.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.ClassTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">ClassTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#ClassTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.ClassTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BaseTag" title="nemo.core.neural_types.BaseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BaseTag</span></code></a></p>
<p>Tag for class dimension.
For example, number of classes in classification problem,
vocabuary size or num of characters for ASR.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.WidthTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">WidthTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#WidthTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.WidthTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BaseTag" title="nemo.core.neural_types.BaseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BaseTag</span></code></a></p>
<p>Tag for width dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.HeightTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">HeightTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#HeightTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.HeightTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BaseTag" title="nemo.core.neural_types.BaseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BaseTag</span></code></a></p>
<p>Tag for width dimension.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.CategoricalTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">CategoricalTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#CategoricalTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.CategoricalTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BatchTag" title="nemo.core.neural_types.BatchTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BatchTag</span></code></a></p>
<p>Tag for labels for classification tasks.</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.RegressionTag">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">RegressionTag</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#RegressionTag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.RegressionTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.BatchTag" title="nemo.core.neural_types.BatchTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.BatchTag</span></code></a></p>
<p>Tag for labels for regression tasks.
For example, this should be used in STS-B task, where labels
represent semantic semilarity score (float)</p>
</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.NeuralTypeComparisonResult">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">NeuralTypeComparisonResult</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#NeuralTypeComparisonResult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeComparisonResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>The result of comparing two neural type objects for compatibility.
When comparing A.compare_to(B):</p>
<dl class="attribute">
<dt id="nemo.core.neural_types.NeuralTypeComparisonResult.DIM_INCOMPATIBLE">
<code class="sig-name descname">DIM_INCOMPATIBLE</code><em class="property"> = 3</em><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeComparisonResult.DIM_INCOMPATIBLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_types.NeuralTypeComparisonResult.GREATER">
<code class="sig-name descname">GREATER</code><em class="property"> = 2</em><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeComparisonResult.GREATER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_types.NeuralTypeComparisonResult.INCOMPATIBLE">
<code class="sig-name descname">INCOMPATIBLE</code><em class="property"> = 5</em><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeComparisonResult.INCOMPATIBLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_types.NeuralTypeComparisonResult.LESS">
<code class="sig-name descname">LESS</code><em class="property"> = 1</em><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeComparisonResult.LESS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_types.NeuralTypeComparisonResult.SAME">
<code class="sig-name descname">SAME</code><em class="property"> = 0</em><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeComparisonResult.SAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_types.NeuralTypeComparisonResult.TRANSPOSE_SAME">
<code class="sig-name descname">TRANSPOSE_SAME</code><em class="property"> = 4</em><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeComparisonResult.TRANSPOSE_SAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.AxisType">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">AxisType</code><span class="sig-paren">(</span><em class="sig-param">semantics</em>, <em class="sig-param">dim: int = None</em>, <em class="sig-param">descriptor: str = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_types.html#AxisType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.AxisType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Every tensor’s axis has semantics, dimension and descriptor.
It’s semantics is a Neural Tag (inherited from BaseTag)
dimension (dim) is (optional) int and descriptor is (optional) string</p>
<dl class="method">
<dt id="nemo.core.neural_types.AxisType.compare_to">
<code class="sig-name descname">compare_to</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_types.html#AxisType.compare_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.AxisType.compare_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares current AxisType object to other</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#nemo.core.neural_types.AxisType" title="nemo.core.neural_types.AxisType"><em>AxisType</em></a>) – other AxisType object to compare with</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Results of a comparison (NeuralTypeComparisonResult)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_types.AxisType.descriptor">
<em class="property">property </em><code class="sig-name descname">descriptor</code><a class="headerlink" href="#nemo.core.neural_types.AxisType.descriptor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_types.AxisType.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#nemo.core.neural_types.AxisType.dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_types.AxisType.semantics">
<em class="property">property </em><code class="sig-name descname">semantics</code><a class="headerlink" href="#nemo.core.neural_types.AxisType.semantics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.NeuralType">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">NeuralType</code><span class="sig-paren">(</span><em class="sig-param">axis2type={}</em>, <em class="sig-param">optional=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_types.html#NeuralType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.NeuralType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Neural Type: a type for NmTensor.</p>
<p>Note: This type mechanism is represented by Python inheritance. That is,
NmTensor
class inherits from NeuralType class.</p>
<p>A Neural Type is a mapping from Tensor’s axis number to it’s type (
AxisType).</p>
<p>To instantiate a NeuralType you should pass it a dictionary (axis2type)
which
will map axis to it’s AxisType. You can also pass optional argument when
describing input ports.</p>
<p>For example, a ResNet18 input can be described as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">NeuralType</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">AxisType</span><span class="p">(</span><span class="n">BatchTag</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">AxisType</span><span class="p">(</span><span class="n">ChannelTag</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">AxisType</span><span class="p">(</span><span class="n">HeightTag</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">AxisType</span><span class="p">(</span><span class="n">WidthTag</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="bp">None</span><span class="p">)})</span>
</pre></div>
</div>
<dl>
<dt>Special cases:</dt><dd><ul class="simple">
<li><p>non-tensor objects should be denoted as NeuralType(None)</p></li>
<li><p>root type is denoted by NeuralType({}). A port of NeuralType({}) must</p></li>
</ul>
<p>accept NmTensors of any NeuralType. More specifically:
root_type = NeuralType({})
root_type.compare(any_other_neural_type) ==
NeuralTypeComparisonResult.SAME</p>
</dd>
</dl>
<p>See “nemo/tests/test_neural_types.py” for more examples.</p>
<dl class="method">
<dt id="nemo.core.neural_types.NeuralType.axis2type">
<em class="property">property </em><code class="sig-name descname">axis2type</code><a class="headerlink" href="#nemo.core.neural_types.NeuralType.axis2type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_types.NeuralType.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param">n_type2</em><span class="sig-paren">)</span> &#x2192; nemo.core.neural_types.NeuralTypeComparisonResult<a class="reference internal" href="../_modules/nemo/core/neural_types.html#NeuralType.compare"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.NeuralType.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares if current object’s NeuralType semantics is compatible
with n_type2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_type2</strong> (<a class="reference internal" href="#nemo.core.neural_types.NeuralType" title="nemo.core.neural_types.NeuralType"><em>NeuralType</em></a>) – a type to compare with</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Results of a comparison (NeuralTypeComparisonResult)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_types.NmTensor">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">NmTensor</code><span class="sig-paren">(</span><em class="sig-param">producer</em>, <em class="sig-param">producer_args</em>, <em class="sig-param">name</em>, <em class="sig-param">ntype=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_types.html#NmTensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.NmTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.NeuralType" title="nemo.core.neural_types.NeuralType"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.NeuralType</span></code></a></p>
<p>Class representing data which flows between NeuralModules’ ports.
It also has a type of NeuralType represented by inheriting from NeuralType
object.</p>
<dl class="method">
<dt id="nemo.core.neural_types.NmTensor.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#nemo.core.neural_types.NmTensor.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
A NmTensor’s name which should be equal to
the NeuralModule’s output port’s name which created it</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_types.NmTensor.producer">
<em class="property">property </em><code class="sig-name descname">producer</code><a class="headerlink" href="#nemo.core.neural_types.NmTensor.producer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
NeuralModule object which produced this NmTensor.</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_types.NmTensor.producer_args">
<em class="property">property </em><code class="sig-name descname">producer_args</code><a class="headerlink" href="#nemo.core.neural_types.NmTensor.producer_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
a dictionary of port_name-&gt;NmTensor value
of arguments which were sent to producer to create this object</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_types.NmTensor.unique_name">
<em class="property">property </em><code class="sig-name descname">unique_name</code><a class="headerlink" href="#nemo.core.neural_types.NmTensor.unique_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Unique NMTensor name.
It is composed of non-unique name (self.name) and uuid of NeuralModule
which created this tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>unique name</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nemo.core.neural_types.NeuralTypeError">
<em class="property">exception </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">NeuralTypeError</code><a class="reference internal" href="../_modules/nemo/core/neural_types.html#NeuralTypeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.NeuralTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Base class for neural type related exceptions.</p>
</dd></dl>

<dl class="exception">
<dt id="nemo.core.neural_types.NeuralPortNameMismatchError">
<em class="property">exception </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">NeuralPortNameMismatchError</code><span class="sig-paren">(</span><em class="sig-param">message</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_types.html#NeuralPortNameMismatchError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.NeuralPortNameMismatchError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.NeuralTypeError" title="nemo.core.neural_types.NeuralTypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.NeuralTypeError</span></code></a></p>
<p>Exception raised when neural module is called with incorrect port
names.</p>
</dd></dl>

<dl class="exception">
<dt id="nemo.core.neural_types.NeuralPortNmTensorMismatchError">
<em class="property">exception </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">NeuralPortNmTensorMismatchError</code><span class="sig-paren">(</span><em class="sig-param">message</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_types.html#NeuralPortNmTensorMismatchError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.NeuralPortNmTensorMismatchError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.NeuralTypeError" title="nemo.core.neural_types.NeuralTypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.NeuralTypeError</span></code></a></p>
<p>Exception raised when a port is fed with a NmTensor of incompatible
type.</p>
</dd></dl>

<dl class="exception">
<dt id="nemo.core.neural_types.CanNotInferResultNeuralType">
<em class="property">exception </em><code class="sig-prename descclassname">nemo.core.neural_types.</code><code class="sig-name descname">CanNotInferResultNeuralType</code><span class="sig-paren">(</span><em class="sig-param">message</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_types.html#CanNotInferResultNeuralType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_types.CanNotInferResultNeuralType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_types.NeuralTypeError" title="nemo.core.neural_types.NeuralTypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_types.NeuralTypeError</span></code></a></p>
<p>Exception raised when NeuralType of output can not be inferred.</p>
</dd></dl>

</div>
<div class="section" id="module-nemo.core.neural_modules">
<span id="neural-modules"></span><h2>neural_modules<a class="headerlink" href="#module-nemo.core.neural_modules" title="Permalink to this headline">¶</a></h2>
<p>This file contains NeuralModule and NmTensor classes.</p>
<dl class="class">
<dt id="nemo.core.neural_modules.WeightShareTransform">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_modules.</code><code class="sig-name descname">WeightShareTransform</code><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#WeightShareTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.WeightShareTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>When sharing parameters, what kind of transform to apply.</p>
<dl class="attribute">
<dt id="nemo.core.neural_modules.WeightShareTransform.SAME">
<code class="sig-name descname">SAME</code><em class="property"> = 0</em><a class="headerlink" href="#nemo.core.neural_modules.WeightShareTransform.SAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_modules.WeightShareTransform.TRANSPOSE">
<code class="sig-name descname">TRANSPOSE</code><em class="property"> = 1</em><a class="headerlink" href="#nemo.core.neural_modules.WeightShareTransform.TRANSPOSE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_modules.NeuralModule">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_modules.</code><code class="sig-name descname">NeuralModule</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">pretrained_model_name=None</em>, <em class="sig-param">create_port_args=None</em>, <em class="sig-param">factory=None</em>, <em class="sig-param">placement=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Abstract class that every Neural Module must inherit from.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pretrained_model_name</strong> (<em>str</em>) – name of pretrained model to use in order
to initialize this neural module</p></li>
<li><p><strong>create_port_args</strong> (<em>dict</em>) – arguments that are passed to create_ports()</p></li>
<li><p><strong>factory</strong> (<a class="reference internal" href="#nemo.core.neural_factory.NeuralModuleFactory" title="nemo.core.neural_factory.NeuralModuleFactory"><em>NeuralModuleFactory</em></a>) – <code class="xref py py-class docutils literal notranslate"><span class="pre">NeuralModuleFactory</span></code> which
created or which should mange this instance. Required for
multi-gpu training.</p></li>
<li><p><strong>placement</strong> (<a class="reference internal" href="#nemo.core.neural_factory.DeviceType" title="nemo.core.neural_factory.DeviceType"><em>DeviceType</em></a>) – (default:None) where this module should
be placed. If provided, this parameter takes precedence over
whatever is specified in factory.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.create_ports">
<em class="property">abstract static </em><code class="sig-name descname">create_ports</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.create_ports"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.create_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>A static function that must be defined by the child Neural Module. It
returns the input and output ports of the module.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Two dictionaries, the first representing the input ports of the
module and the second representing the output ports of the module</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.factory">
<em class="property">property </em><code class="sig-name descname">factory</code><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Neural module factory which created this module
Returns: NeuralModuleFactory instance or None</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.freeze">
<em class="property">abstract </em><code class="sig-name descname">freeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.freeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to freeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are freezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.get_config_dict_and_checkpoint">
<code class="sig-name descname">get_config_dict_and_checkpoint</code><span class="sig-paren">(</span><em class="sig-param">pretrained_model_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.get_config_dict_and_checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.get_config_dict_and_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING: This part is work in progress</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.get_weights">
<em class="property">abstract </em><code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[Dict[str, bool]]<a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.get_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns NeuralModule’s weights copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary of name -&gt; (weights, trainable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.input_ports">
<em class="property">property </em><code class="sig-name descname">input_ports</code><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.input_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all module’s input ports</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A (dict) of module’s input ports names to NeuralTypes mapping</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.is_trainable">
<code class="sig-name descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.is_trainable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if NeuralModule is trainable.
A NeuralModule is trainable IFF it contains at least one trainable
weight</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if module has trainable weights, False otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.list_pretrained_models">
<em class="property">static </em><code class="sig-name descname">list_pretrained_models</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[List[nemo.core.neural_modules.PretrainedModleInfo]]<a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.list_pretrained_models"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.list_pretrained_models" title="Permalink to this definition">¶</a></dt>
<dd><p>List all available pre-trained models (e.g. weights) for this NM.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of PretrainedModelInfo tuples.
The pretrained_model_name field of the tuple can be used to
retrieve pre-trained model’s weights (pass it as
pretrained_model_name argument to the module’s constructor)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.local_parameters">
<em class="property">property </em><code class="sig-name descname">local_parameters</code><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.local_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get module’s parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>module’s parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.num_weights">
<em class="property">abstract property </em><code class="sig-name descname">num_weights</code><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.num_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of module’s weights</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.output_ports">
<em class="property">property </em><code class="sig-name descname">output_ports</code><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.output_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all module’s output ports</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A (dict) of module’s output ports names to NeuralTypes mapping</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.placement">
<em class="property">property </em><code class="sig-name descname">placement</code><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Module’s placement. Currently CPU or GPU.
DataParallel and ModelParallel will come later.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(DeviceType) Device where NM’s weights are located</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.pretrained_storage">
<em class="property">static </em><code class="sig-name descname">pretrained_storage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.pretrained_storage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.pretrained_storage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.restore_from">
<em class="property">abstract </em><code class="sig-name descname">restore_from</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.restore_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.restore_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore module’s state from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to where to restore from.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.save_to">
<em class="property">abstract </em><code class="sig-name descname">save_to</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.save_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.save_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Save module state to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to while where to save.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.set_weights">
<em class="property">abstract </em><code class="sig-name descname">set_weights</code><span class="sig-paren">(</span><em class="sig-param">name2weight: Dict[str, Tuple[str, bool]], name2name_and_transform: Dict[str, Tuple[str, nemo.core.neural_modules.WeightShareTransform]] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.set_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.set_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets weight from given values. For every named weight in
name2weight,
if weight with the same name is found in the model, it will be set to
found value.</p>
<p>WARNING: This will NOT tie weights. It will copy values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weight</span></code>.
Then, if <code class="docutils literal notranslate"><span class="pre">name2name_and_transform['X']=('Y',</span>
<span class="pre">WeightShareTransform.TRANSPOSE)</span></code>
and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is 5x3 weight and <code class="docutils literal notranslate"><span class="pre">name2weight['Y']=Y.</span> <span class="pre">Then:</span>
<span class="pre">``object1.set_weights(name2weight,</span> <span class="pre">name2name_and_transform)</span></code> will
set object1.X=transpose(Y).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name2weight</strong> (<em>dict</em>) – dictionary of name to (weight, trainable).</p></li>
<li><p><strong>this is output of get_weights method.</strong> (<em>Typically</em>) – </p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.tie_weights_with">
<em class="property">abstract </em><code class="sig-name descname">tie_weights_with</code><span class="sig-paren">(</span><em class="sig-param">module, weight_names=typing.List[str], name2name_and_transform: Dict[str, Tuple[str, nemo.core.neural_modules.WeightShareTransform]] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.tie_weights_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.tie_weights_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Ties weights between self and module. For every weight name in
weight_names, if weight with the same name is found in self, it will
be tied
with a same weight from <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<p>WARNING: Once weights are tied, updates to one weights’s weights
will affect
other module’s weights.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weights</span></code>
and <code class="docutils literal notranslate"><span class="pre">object2.Y</span> <span class="pre">=</span> <span class="pre">5x3</span> <span class="pre">weights</span></code>. Then these weights can be tied like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">object1</span><span class="o">.</span><span class="n">tie_weights_with</span><span class="p">(</span><span class="n">object2</span><span class="p">,</span> <span class="n">weight_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span>
<span class="n">name2name_and_transform</span> <span class="o">=</span>
<span class="p">{</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">WeightShareTransform</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">)})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – with which module to tie weights</p></li>
<li><p><strong>weight_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – list of self weights’ names</p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.unfreeze">
<em class="property">abstract </em><code class="sig-name descname">unfreeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.unfreeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.unfreeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Unfreeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to unfreeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are unfreezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.unique_instance_id">
<em class="property">property </em><code class="sig-name descname">unique_instance_id</code><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.unique_instance_id" title="Permalink to this definition">¶</a></dt>
<dd><p>A unique instance id for this object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A uniq uuid which can be used to identify this object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_modules.NeuralModule.update_local_params">
<em class="property">static </em><code class="sig-name descname">update_local_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_modules.html#NeuralModule.update_local_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_modules.NeuralModule.update_local_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Loops through the call chain of class initializations and stops at the
first class that is not an instance of Neural Module. At each step of
the loop, the class contructor arguments are added to a dictionary
containing the local parameters used to construct the Neural Module</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dictionary containing all parameters passed to the module’s init
chain.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nemo.core.neural_factory">
<span id="neural-factory"></span><h2>neural_factory<a class="headerlink" href="#module-nemo.core.neural_factory" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nemo.core.neural_factory.Backend">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_factory.</code><code class="sig-name descname">Backend</code><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Backend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Supported backends. For now, it is only PyTorch.</p>
<dl class="attribute">
<dt id="nemo.core.neural_factory.Backend.NotSupported">
<code class="sig-name descname">NotSupported</code><em class="property"> = 2</em><a class="headerlink" href="#nemo.core.neural_factory.Backend.NotSupported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.Backend.PyTorch">
<code class="sig-name descname">PyTorch</code><em class="property"> = 1</em><a class="headerlink" href="#nemo.core.neural_factory.Backend.PyTorch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_factory.ModelMode">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_factory.</code><code class="sig-name descname">ModelMode</code><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#ModelMode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.ModelMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Training Mode or Evaluation/Inference</p>
<dl class="attribute">
<dt id="nemo.core.neural_factory.ModelMode.eval">
<code class="sig-name descname">eval</code><em class="property"> = 1</em><a class="headerlink" href="#nemo.core.neural_factory.ModelMode.eval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.ModelMode.train">
<code class="sig-name descname">train</code><em class="property"> = 0</em><a class="headerlink" href="#nemo.core.neural_factory.ModelMode.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_factory.Optimization">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_factory.</code><code class="sig-name descname">Optimization</code><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Optimization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Various levels of Apex/amp Optimization.
WARNING: This might have effect on model accuracy.</p>
<dl class="attribute">
<dt id="nemo.core.neural_factory.Optimization.mxprO0">
<code class="sig-name descname">mxprO0</code><em class="property"> = 0</em><a class="headerlink" href="#nemo.core.neural_factory.Optimization.mxprO0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.Optimization.mxprO1">
<code class="sig-name descname">mxprO1</code><em class="property"> = 1</em><a class="headerlink" href="#nemo.core.neural_factory.Optimization.mxprO1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.Optimization.mxprO2">
<code class="sig-name descname">mxprO2</code><em class="property"> = 2</em><a class="headerlink" href="#nemo.core.neural_factory.Optimization.mxprO2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.Optimization.mxprO3">
<code class="sig-name descname">mxprO3</code><em class="property"> = 3</em><a class="headerlink" href="#nemo.core.neural_factory.Optimization.mxprO3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_factory.DeviceType">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_factory.</code><code class="sig-name descname">DeviceType</code><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#DeviceType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.DeviceType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Device types where Neural Modules can be placed.</p>
<dl class="attribute">
<dt id="nemo.core.neural_factory.DeviceType.AllGpu">
<code class="sig-name descname">AllGpu</code><em class="property"> = 3</em><a class="headerlink" href="#nemo.core.neural_factory.DeviceType.AllGpu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.DeviceType.CPU">
<code class="sig-name descname">CPU</code><em class="property"> = 2</em><a class="headerlink" href="#nemo.core.neural_factory.DeviceType.CPU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.DeviceType.GPU">
<code class="sig-name descname">GPU</code><em class="property"> = 1</em><a class="headerlink" href="#nemo.core.neural_factory.DeviceType.GPU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_factory.Actions">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_factory.</code><code class="sig-name descname">Actions</code><span class="sig-paren">(</span><em class="sig-param">local_rank</em>, <em class="sig-param">global_rank</em>, <em class="sig-param">optimization_level=&lt;Optimization.mxprO0: 0&gt;</em>, <em class="sig-param">logger=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Actions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Actions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Basic actions allowed on graphs of Neural Modules</p>
<dl class="method">
<dt id="nemo.core.neural_factory.Actions.create_optimizer">
<em class="property">abstract </em><code class="sig-name descname">create_optimizer</code><span class="sig-paren">(</span><em class="sig-param">optimizer</em>, <em class="sig-param">things_to_optimize</em>, <em class="sig-param">optimizer_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Actions.create_optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Actions.create_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an optimizer object to be use in the train() method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optimizer</strong> – Specifies which optimizer to use.</p></li>
<li><p><strong>things_to_optimize</strong> – A list of neural modules or tensors to be
optimized.</p></li>
<li><p><strong>optimizer_params</strong> – Specifies the parameters of the optimizer</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Optimizer</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.Actions.global_rank">
<em class="property">property </em><code class="sig-name descname">global_rank</code><a class="headerlink" href="#nemo.core.neural_factory.Actions.global_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Global rank during distributed execution. None if single GPU/CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(int) rank or worker or None if not in distributed model</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.Actions.infer">
<em class="property">abstract </em><code class="sig-name descname">infer</code><span class="sig-paren">(</span><em class="sig-param">tensors: List[nemo.core.neural_types.NmTensor]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Actions.infer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Actions.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>This action executes inference. Nothing is optimized.
:param tensors: which tensors to evaluate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.Actions.local_rank">
<em class="property">property </em><code class="sig-name descname">local_rank</code><a class="headerlink" href="#nemo.core.neural_factory.Actions.local_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Local rank during distributed execution. None if single GPU/CPU</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(int) rank or worker or None if not in distributed model</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.Actions.restore_state_from">
<em class="property">abstract </em><code class="sig-name descname">restore_state_from</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Actions.restore_state_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Actions.restore_state_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restores state such as step, epoch and optimizer parameters
:param path:</p>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.Actions.save_state_to">
<em class="property">abstract </em><code class="sig-name descname">save_state_to</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Actions.save_state_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Actions.save_state_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves current state such as step, epoch and optimizer parameters
:param path:</p>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.Actions.train">
<em class="property">abstract </em><code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">tensors_to_optimize: List[nemo.core.neural_types.NmTensor], callbacks: Optional[List[nemo.core.callbacks.ActionCallback]], lr_policy=None, batches_per_step=None, stop_on_nan_loss=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#Actions.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.Actions.train" title="Permalink to this definition">¶</a></dt>
<dd><p>This action executes training and (optionally) evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors_to_optimize</strong> – which tensors to optimize. Typically this is
single loss tesnor.</p></li>
<li><p><strong>callbacks</strong> – list of callback objects</p></li>
<li><p><strong>lr_policy</strong> – function which should take (initial_lr, step, epoch) and
return learning rate</p></li>
<li><p><strong>batches_per_step</strong> – number of mini-batches to process before one
optimizer step. (default: None, same as 1). Use this
to simulate larger batch sizes on hardware which could not fit
larger batch in memory otherwise. Effectively, this will make
“algorithmic” batch size per GPU/worker = batches_per_step*
batch_size</p></li>
<li><p><strong>stop_on_nan_loss</strong> – (default: False) If set to True, the training
will stop if loss=nan. If set to False, the training will
continue, but the gradients will be zeroed before next
mini-batch.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_factory.NeuralModuleFactory">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_factory.</code><code class="sig-name descname">NeuralModuleFactory</code><span class="sig-paren">(</span><em class="sig-param">backend=&lt;Backend.PyTorch: 1&gt;</em>, <em class="sig-param">local_rank=None</em>, <em class="sig-param">optimization_level=&lt;Optimization.mxprO0: 0&gt;</em>, <em class="sig-param">placement=None</em>, <em class="sig-param">cudnn_benchmark=False</em>, <em class="sig-param">random_seed=None</em>, <em class="sig-param">set_default=True</em>, <em class="sig-param">log_dir=None</em>, <em class="sig-param">checkpoint_dir=None</em>, <em class="sig-param">tensorboard_dir=None</em>, <em class="sig-param">create_tb_writer=False</em>, <em class="sig-param">files_to_copy=None</em>, <em class="sig-param">add_time_to_log_dir=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.checkpoint_dir">
<em class="property">property </em><code class="sig-name descname">checkpoint_dir</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.checkpoint_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.clear_cache">
<code class="sig-name descname">clear_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.clear_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to clean inference cache.</p>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.create_optimizer">
<code class="sig-name descname">create_optimizer</code><span class="sig-paren">(</span><em class="sig-param">optimizer</em>, <em class="sig-param">things_to_optimize</em>, <em class="sig-param">optimizer_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.create_optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.create_optimizer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.deployment_export">
<code class="sig-name descname">deployment_export</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">output: str</em>, <em class="sig-param">d_format: nemo.core.neural_factory.DeploymentFormat</em>, <em class="sig-param">input_example=None</em>, <em class="sig-param">output_example=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.deployment_export"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.deployment_export" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports Neural Module instance for deployment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – neural module to export</p></li>
<li><p><strong>output</strong> (<em>str</em>) – where export results should be saved</p></li>
<li><p><strong>d_format</strong> (<a class="reference internal" href="#nemo.core.neural_factory.DeploymentFormat" title="nemo.core.neural_factory.DeploymentFormat"><em>DeploymentFormat</em></a>) – which deployment format to use</p></li>
<li><p><strong>input_example</strong> – sometimes tracing will require input examples</p></li>
<li><p><strong>output_example</strong> – Should match inference on input_example</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">callbacks: List[nemo.core.callbacks.EvaluatorCallback]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.eval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.get_default_factory">
<em class="property">classmethod </em><code class="sig-name descname">get_default_factory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.get_default_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.get_default_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.get_module">
<code class="sig-name descname">get_module</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">params</em>, <em class="sig-param">collection</em>, <em class="sig-param">pretrained=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.get_module"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.get_module" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates NeuralModule instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – name of NeuralModule which instance should be returned.</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – local parameters which should be passed to</p></li>
<li><p><strong>constructor.</strong> (<em>NeuralModule's</em>) – </p></li>
<li><p><strong>collection</strong> (<em>str</em>) – in which collection to look for</p></li>
<li><p><strong>neural_module_name</strong> – </p></li>
<li><p><strong>pretrained</strong> (<em>bool</em>) – return pre-trained instance or randomly</p></li>
<li><p><strong>initialized</strong> (<em>default</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NeuralModule instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.get_trainer">
<code class="sig-name descname">get_trainer</code><span class="sig-paren">(</span><em class="sig-param">tb_writer=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.get_trainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.get_trainer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.global_rank">
<em class="property">property </em><code class="sig-name descname">global_rank</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.global_rank" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.infer">
<code class="sig-name descname">infer</code><span class="sig-paren">(</span><em class="sig-param">tensors: List[nemo.core.neural_types.NmTensor], checkpoint_dir=None, ckpt_pattern='', verbose=True, cache=False, use_cache=False, offload_to_cpu=True, modules_to_restore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.infer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs inference to obtain values for tensors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><a class="reference internal" href="#nemo.core.neural_types.NmTensor" title="nemo.core.neural_types.NmTensor"><em>NmTensor</em></a><em>]</em>) – List of NeMo tensors that we want to get
values of.</p></li>
<li><p><strong>checkpoint_dir</strong> (<em>str</em>) – Path to checkpoint directory. Default is None
which does not load checkpoints.</p></li>
<li><p><strong>ckpt_pattern</strong> (<em>str</em>) – Pattern used to check for checkpoints inside
checkpoint_dir. Default is ‘’ which matches any checkpoints
inside checkpoint_dir.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Controls printing. Defaults to True.</p></li>
<li><p><strong>cache</strong> (<em>bool</em>) – If True, cache all <cite>tensors</cite> and intermediate tensors
so that future calls that have use_cache set will avoid
computation. Defaults to False.</p></li>
<li><p><strong>use_cache</strong> (<em>bool</em>) – Values from <cite>tensors</cite> will be always re-computed.
It will re-use intermediate tensors from the DAG leading to
<cite>tensors</cite>. If you want something to be re-computed, put it into
<cite>tensors</cite> list. Defaults to False.</p></li>
<li><p><strong>offload_to_cpu</strong> (<em>bool</em>) – If True, all evaluated tensors are moved to
cpu memory after each inference batch. Defaults to True.</p></li>
<li><p><strong>modules_to_restore</strong> (<em>list</em>) – Defaults to None, in which case all
NMs inside callchain with weights will be restored. If
specified only the modules inside this list will be restored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of evaluated tensors. Each element in the list is also a list
where each element is now a batch of tensor values.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.logger">
<em class="property">property </em><code class="sig-name descname">logger</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.logger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.optim_level">
<em class="property">property </em><code class="sig-name descname">optim_level</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.optim_level" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.placement">
<em class="property">property </em><code class="sig-name descname">placement</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.placement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.reset_default_factory">
<em class="property">classmethod </em><code class="sig-name descname">reset_default_factory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.reset_default_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.reset_default_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.reset_trainer">
<code class="sig-name descname">reset_trainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.reset_trainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.reset_trainer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.set_default_factory">
<em class="property">classmethod </em><code class="sig-name descname">set_default_factory</code><span class="sig-paren">(</span><em class="sig-param">factory</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.set_default_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.set_default_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.sync_all_processes">
<code class="sig-name descname">sync_all_processes</code><span class="sig-paren">(</span><em class="sig-param">status=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.sync_all_processes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.sync_all_processes" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for testing that allows proccess 0 to inform all
other processes of failures. Does nothing if not using distributed
training. Usage example can be seen in examples/asr/jasper_an4.py</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>status</strong> (<em>bool</em>) – Defaults to True. If any proccess passes False, it
will trigger a graceful exit on all other processes. It is
assumed that the process that passed False will print an error
message on its own and exit</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.tb_writer">
<em class="property">property </em><code class="sig-name descname">tb_writer</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.tb_writer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">tensors_to_optimize</em>, <em class="sig-param">optimizer=None</em>, <em class="sig-param">optimization_params=None</em>, <em class="sig-param">callbacks: Optional[List[nemo.core.callbacks.ActionCallback]] = None</em>, <em class="sig-param">lr_policy=None</em>, <em class="sig-param">batches_per_step=None</em>, <em class="sig-param">stop_on_nan_loss=False</em>, <em class="sig-param">synced_batchnorm=False</em>, <em class="sig-param">synced_batchnorm_groupsize=0</em>, <em class="sig-param">gradient_predivide=False</em>, <em class="sig-param">amp_max_loss_scale=16777216.0</em>, <em class="sig-param">reset=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#NeuralModuleFactory.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.work_dir">
<em class="property">property </em><code class="sig-name descname">work_dir</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.work_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.core.neural_factory.NeuralModuleFactory.world_size">
<em class="property">property </em><code class="sig-name descname">world_size</code><a class="headerlink" href="#nemo.core.neural_factory.NeuralModuleFactory.world_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.core.neural_factory.DeploymentFormat">
<em class="property">class </em><code class="sig-prename descclassname">nemo.core.neural_factory.</code><code class="sig-name descname">DeploymentFormat</code><a class="reference internal" href="../_modules/nemo/core/neural_factory.html#DeploymentFormat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.core.neural_factory.DeploymentFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Which format to use when exporting a Neural Module for deployment</p>
<dl class="attribute">
<dt id="nemo.core.neural_factory.DeploymentFormat.AUTO">
<code class="sig-name descname">AUTO</code><em class="property"> = 0</em><a class="headerlink" href="#nemo.core.neural_factory.DeploymentFormat.AUTO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.DeploymentFormat.ONNX">
<code class="sig-name descname">ONNX</code><em class="property"> = 3</em><a class="headerlink" href="#nemo.core.neural_factory.DeploymentFormat.ONNX" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.DeploymentFormat.PYTORCH">
<code class="sig-name descname">PYTORCH</code><em class="property"> = 1</em><a class="headerlink" href="#nemo.core.neural_factory.DeploymentFormat.PYTORCH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nemo.core.neural_factory.DeploymentFormat.TORCHSCRIPT">
<code class="sig-name descname">TORCHSCRIPT</code><em class="property"> = 2</em><a class="headerlink" href="#nemo.core.neural_factory.DeploymentFormat.TORCHSCRIPT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="pytorch">
<h1>PyTorch 后端<a class="headerlink" href="#pytorch" title="Permalink to this headline">¶</a></h1>
<p>当前我们只支持 PyTorch 后端。</p>
<div class="section" id="module-nemo.backends.pytorch.actions">
<span id="id1"></span><h2>基本操作<a class="headerlink" href="#module-nemo.backends.pytorch.actions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nemo.backends.pytorch.actions.PtActions">
<em class="property">class </em><code class="sig-prename descclassname">nemo.backends.pytorch.actions.</code><code class="sig-name descname">PtActions</code><span class="sig-paren">(</span><em class="sig-param">local_rank=None</em>, <em class="sig-param">global_rank=None</em>, <em class="sig-param">tb_writer=None</em>, <em class="sig-param">optimization_level=&lt;Optimization.mxprO0: 0&gt;</em>, <em class="sig-param">logger=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_factory.Actions" title="nemo.core.neural_factory.Actions"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_factory.Actions</span></code></a></p>
<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.append_to_cache">
<code class="sig-name descname">append_to_cache</code><span class="sig-paren">(</span><em class="sig-param">registered_tensors: dict</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.append_to_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.append_to_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Simpler helper function to add results of __nm_graph_forward_pass to
current cache.</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.clear_cache">
<code class="sig-name descname">clear_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.clear_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple helpful function to clear cache by setting self.cache to
None</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.create_optimizer">
<code class="sig-name descname">create_optimizer</code><span class="sig-paren">(</span><em class="sig-param">optimizer</em>, <em class="sig-param">things_to_optimize</em>, <em class="sig-param">optimizer_params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.create_optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.create_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function around __setup_optimizer()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optimizer</strong> – A instantiated PyTorch optimizer or string. For
currently supported strings, see __setup_optimizer().</p></li>
<li><p><strong>things_to_optimize</strong> (<em>list</em>) – Must be a list of Neural Modules and/or
parameters. If a Neural Module is passed, all trainable
parameters are extracted and passed to the optimizer.</p></li>
<li><p><strong>optimizer_params</strong> (<em>dict</em>) – Optional parameters dictionary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Optimizer</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.depad_tensor">
<em class="property">static </em><code class="sig-name descname">depad_tensor</code><span class="sig-paren">(</span><em class="sig-param">t: torch.Tensor</em>, <em class="sig-param">original_size: torch.Size</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.depad_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.depad_tensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.deployment_export">
<em class="property">static </em><code class="sig-name descname">deployment_export</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">output: str</em>, <em class="sig-param">d_format: nemo.core.neural_factory.DeploymentFormat</em>, <em class="sig-param">input_example=None</em>, <em class="sig-param">output_example=None</em>, <em class="sig-param">logger=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.deployment_export"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.deployment_export" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports Neural Module instance for deployment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – neural module to export</p></li>
<li><p><strong>output</strong> (<em>str</em>) – where export results should be saved</p></li>
<li><p><strong>d_format</strong> (<a class="reference internal" href="#nemo.core.neural_factory.DeploymentFormat" title="nemo.core.neural_factory.DeploymentFormat"><em>DeploymentFormat</em></a>) – which deployment format to use</p></li>
<li><p><strong>input_example</strong> – sometimes tracing will require input examples</p></li>
<li><p><strong>output_example</strong> – Should match inference on input_example</p></li>
<li><p><strong>amp_max_loss_scale</strong> (<em>float</em>) – Max value for amp loss scaling.
Defaults to 2.0**24.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.infer">
<code class="sig-name descname">infer</code><span class="sig-paren">(</span><em class="sig-param">tensors</em>, <em class="sig-param">checkpoint_dir=None</em>, <em class="sig-param">ckpt_pattern=''</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">verbose=True</em>, <em class="sig-param">cache=False</em>, <em class="sig-param">use_cache=False</em>, <em class="sig-param">offload_to_cpu=True</em>, <em class="sig-param">modules_to_restore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.infer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>See NeuralModuleFactory.infer()</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.modules">
<em class="property">property </em><code class="sig-name descname">modules</code><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.modules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.pad_tensor">
<em class="property">static </em><code class="sig-name descname">pad_tensor</code><span class="sig-paren">(</span><em class="sig-param">t: torch.Tensor</em>, <em class="sig-param">target_size: torch.Size</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.pad_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.pad_tensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.restore_state_from">
<code class="sig-name descname">restore_state_from</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.restore_state_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.restore_state_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restores state such as step, epoch and optimizer parameters
:param path:</p>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.save_state_to">
<code class="sig-name descname">save_state_to</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.save_state_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.save_state_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves current state such as step, epoch and optimizer parameters
:param path:</p>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.actions.PtActions.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">tensors_to_optimize</em>, <em class="sig-param">optimizer=None</em>, <em class="sig-param">optimization_params=None</em>, <em class="sig-param">callbacks: Optional[List[nemo.core.callbacks.ActionCallback]] = None</em>, <em class="sig-param">lr_policy=None</em>, <em class="sig-param">batches_per_step=None</em>, <em class="sig-param">stop_on_nan_loss=False</em>, <em class="sig-param">synced_batchnorm=False</em>, <em class="sig-param">synced_batchnorm_groupsize=0</em>, <em class="sig-param">gradient_predivide=False</em>, <em class="sig-param">amp_max_loss_scale=16777216.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/actions.html#PtActions.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.actions.PtActions.train" title="Permalink to this definition">¶</a></dt>
<dd><p>This action executes training and (optionally) evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors_to_optimize</strong> – which tensors to optimize. Typically this is
single loss tesnor.</p></li>
<li><p><strong>callbacks</strong> – list of callback objects</p></li>
<li><p><strong>lr_policy</strong> – function which should take (initial_lr, step, epoch) and
return learning rate</p></li>
<li><p><strong>batches_per_step</strong> – number of mini-batches to process before one
optimizer step. (default: None, same as 1). Use this
to simulate larger batch sizes on hardware which could not fit
larger batch in memory otherwise. Effectively, this will make
“algorithmic” batch size per GPU/worker = batches_per_step*
batch_size</p></li>
<li><p><strong>stop_on_nan_loss</strong> – (default: False) If set to True, the training
will stop if loss=nan. If set to False, the training will
continue, but the gradients will be zeroed before next
mini-batch.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nemo.backends.pytorch.nm">
<span id="id2"></span><h2>写你自己的神经模块需要的类<a class="headerlink" href="#module-nemo.backends.pytorch.nm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nemo.backends.pytorch.nm.DataLayerNM">
<em class="property">class </em><code class="sig-prename descclassname">nemo.backends.pytorch.nm.</code><code class="sig-name descname">DataLayerNM</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_modules.NeuralModule" title="nemo.core.neural_modules.NeuralModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_modules.NeuralModule</span></code></a></p>
<p>A helper Base class for creating Pytorch-based data layers.
You must implement __len__ method to return dataset size and
data_iterator property to return iterator over the dataset.</p>
<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.data_iterator">
<em class="property">abstract property </em><code class="sig-name descname">data_iterator</code><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.data_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>“Iterator over the dataset. It is a good idea to return
torch.utils.data.DataLoader here. Should implement either this or
<cite>dataset</cite>.
If this is implemented, <cite>dataset</cite> property should return None.</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.dataset">
<em class="property">abstract property </em><code class="sig-name descname">dataset</code><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Should return an instance of torch.utils.data.Dataset. Should
implement
either this or <cite>data_iterator</cite>. If this is implemented, <cite>data_iterator</cite>
should return None.</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM.freeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to freeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are freezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.get_weights">
<code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM.get_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns NeuralModule’s weights copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary of name -&gt; (weights, trainable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.num_weights">
<em class="property">property </em><code class="sig-name descname">num_weights</code><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.num_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of module’s weights</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.restore_from">
<code class="sig-name descname">restore_from</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM.restore_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.restore_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore module’s state from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to where to restore from.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.save_to">
<code class="sig-name descname">save_to</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM.save_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.save_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Save module state to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to while where to save.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.set_weights">
<code class="sig-name descname">set_weights</code><span class="sig-paren">(</span><em class="sig-param">name2weight: Dict[str, bool], name2name_and_transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM.set_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.set_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets weight from given values. For every named weight in
name2weight,
if weight with the same name is found in the model, it will be set to
found value.</p>
<p>WARNING: This will NOT tie weights. It will copy values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weight</span></code>.
Then, if <code class="docutils literal notranslate"><span class="pre">name2name_and_transform['X']=('Y',</span>
<span class="pre">WeightShareTransform.TRANSPOSE)</span></code>
and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is 5x3 weight and <code class="docutils literal notranslate"><span class="pre">name2weight['Y']=Y.</span> <span class="pre">Then:</span>
<span class="pre">``object1.set_weights(name2weight,</span> <span class="pre">name2name_and_transform)</span></code> will
set object1.X=transpose(Y).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name2weight</strong> (<em>dict</em>) – dictionary of name to (weight, trainable).</p></li>
<li><p><strong>this is output of get_weights method.</strong> (<em>Typically</em>) – </p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.tie_weights_with">
<code class="sig-name descname">tie_weights_with</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">weight_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM.tie_weights_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.tie_weights_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Ties weights between self and module. For every weight name in
weight_names, if weight with the same name is found in self, it will
be tied
with a same weight from <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<p>WARNING: Once weights are tied, updates to one weights’s weights
will affect
other module’s weights.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weights</span></code>
and <code class="docutils literal notranslate"><span class="pre">object2.Y</span> <span class="pre">=</span> <span class="pre">5x3</span> <span class="pre">weights</span></code>. Then these weights can be tied like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">object1</span><span class="o">.</span><span class="n">tie_weights_with</span><span class="p">(</span><span class="n">object2</span><span class="p">,</span> <span class="n">weight_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span>
<span class="n">name2name_and_transform</span> <span class="o">=</span>
<span class="p">{</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">WeightShareTransform</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">)})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – with which module to tie weights</p></li>
<li><p><strong>weight_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – list of self weights’ names</p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.DataLayerNM.unfreeze">
<code class="sig-name descname">unfreeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#DataLayerNM.unfreeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.DataLayerNM.unfreeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Unfreeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to unfreeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are unfreezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.backends.pytorch.nm.LossNM">
<em class="property">class </em><code class="sig-prename descclassname">nemo.backends.pytorch.nm.</code><code class="sig-name descname">LossNM</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_modules.NeuralModule" title="nemo.core.neural_modules.NeuralModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_modules.NeuralModule</span></code></a></p>
<p>A helper Base class for creating Pytorch-based loss function modules.
You must implement _loss_function method.</p>
<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM.freeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to freeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are freezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.get_weights">
<code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM.get_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns NeuralModule’s weights copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary of name -&gt; (weights, trainable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.num_weights">
<em class="property">property </em><code class="sig-name descname">num_weights</code><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.num_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of module’s weights</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.restore_from">
<code class="sig-name descname">restore_from</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM.restore_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.restore_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore module’s state from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to where to restore from.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.save_to">
<code class="sig-name descname">save_to</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM.save_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.save_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Save module state to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to while where to save.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.set_weights">
<code class="sig-name descname">set_weights</code><span class="sig-paren">(</span><em class="sig-param">name2weight: Dict[str, bool], name2name_and_transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM.set_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.set_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets weight from given values. For every named weight in
name2weight,
if weight with the same name is found in the model, it will be set to
found value.</p>
<p>WARNING: This will NOT tie weights. It will copy values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weight</span></code>.
Then, if <code class="docutils literal notranslate"><span class="pre">name2name_and_transform['X']=('Y',</span>
<span class="pre">WeightShareTransform.TRANSPOSE)</span></code>
and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is 5x3 weight and <code class="docutils literal notranslate"><span class="pre">name2weight['Y']=Y.</span> <span class="pre">Then:</span>
<span class="pre">``object1.set_weights(name2weight,</span> <span class="pre">name2name_and_transform)</span></code> will
set object1.X=transpose(Y).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name2weight</strong> (<em>dict</em>) – dictionary of name to (weight, trainable).</p></li>
<li><p><strong>this is output of get_weights method.</strong> (<em>Typically</em>) – </p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.tie_weights_with">
<code class="sig-name descname">tie_weights_with</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">weight_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM.tie_weights_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.tie_weights_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Ties weights between self and module. For every weight name in
weight_names, if weight with the same name is found in self, it will
be tied
with a same weight from <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<p>WARNING: Once weights are tied, updates to one weights’s weights
will affect
other module’s weights.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weights</span></code>
and <code class="docutils literal notranslate"><span class="pre">object2.Y</span> <span class="pre">=</span> <span class="pre">5x3</span> <span class="pre">weights</span></code>. Then these weights can be tied like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">object1</span><span class="o">.</span><span class="n">tie_weights_with</span><span class="p">(</span><span class="n">object2</span><span class="p">,</span> <span class="n">weight_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span>
<span class="n">name2name_and_transform</span> <span class="o">=</span>
<span class="p">{</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">WeightShareTransform</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">)})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – with which module to tie weights</p></li>
<li><p><strong>weight_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – list of self weights’ names</p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.LossNM.unfreeze">
<code class="sig-name descname">unfreeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#LossNM.unfreeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.LossNM.unfreeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Unfreeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to unfreeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are unfreezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM">
<em class="property">class </em><code class="sig-prename descclassname">nemo.backends.pytorch.nm.</code><code class="sig-name descname">NonTrainableNM</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_modules.NeuralModule" title="nemo.core.neural_modules.NeuralModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_modules.NeuralModule</span></code></a></p>
<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.forward">
<code class="sig-name descname">forward</code><span class="sig-paren">(</span><em class="sig-param">*input</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.forward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.freeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to freeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are freezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.get_weights">
<code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[Dict[str, bool]]<a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.get_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns NeuralModule’s weights copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary of name -&gt; (weights, trainable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.num_weights">
<em class="property">property </em><code class="sig-name descname">num_weights</code><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.num_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of module’s weights</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.restore_from">
<code class="sig-name descname">restore_from</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.restore_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.restore_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore module’s state from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to where to restore from.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.save_to">
<code class="sig-name descname">save_to</code><span class="sig-paren">(</span><em class="sig-param">path: str</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.save_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.save_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Save module state to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to while where to save.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.set_weights">
<code class="sig-name descname">set_weights</code><span class="sig-paren">(</span><em class="sig-param">name2weight: Dict[str, Tuple[str, bool]], name2name_and_transform: Dict[str, Tuple[str, nemo.core.neural_modules.WeightShareTransform]] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.set_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.set_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets weight from given values. For every named weight in
name2weight,
if weight with the same name is found in the model, it will be set to
found value.</p>
<p>WARNING: This will NOT tie weights. It will copy values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weight</span></code>.
Then, if <code class="docutils literal notranslate"><span class="pre">name2name_and_transform['X']=('Y',</span>
<span class="pre">WeightShareTransform.TRANSPOSE)</span></code>
and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is 5x3 weight and <code class="docutils literal notranslate"><span class="pre">name2weight['Y']=Y.</span> <span class="pre">Then:</span>
<span class="pre">``object1.set_weights(name2weight,</span> <span class="pre">name2name_and_transform)</span></code> will
set object1.X=transpose(Y).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name2weight</strong> (<em>dict</em>) – dictionary of name to (weight, trainable).</p></li>
<li><p><strong>this is output of get_weights method.</strong> (<em>Typically</em>) – </p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.tie_weights_with">
<code class="sig-name descname">tie_weights_with</code><span class="sig-paren">(</span><em class="sig-param">module, weight_names=typing.List[str], name2name_and_transform: Dict[str, Tuple[str, nemo.core.neural_modules.WeightShareTransform]] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.tie_weights_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.tie_weights_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Ties weights between self and module. For every weight name in
weight_names, if weight with the same name is found in self, it will
be tied
with a same weight from <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<p>WARNING: Once weights are tied, updates to one weights’s weights
will affect
other module’s weights.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weights</span></code>
and <code class="docutils literal notranslate"><span class="pre">object2.Y</span> <span class="pre">=</span> <span class="pre">5x3</span> <span class="pre">weights</span></code>. Then these weights can be tied like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">object1</span><span class="o">.</span><span class="n">tie_weights_with</span><span class="p">(</span><span class="n">object2</span><span class="p">,</span> <span class="n">weight_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span>
<span class="n">name2name_and_transform</span> <span class="o">=</span>
<span class="p">{</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">WeightShareTransform</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">)})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – with which module to tie weights</p></li>
<li><p><strong>weight_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – list of self weights’ names</p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.NonTrainableNM.unfreeze">
<code class="sig-name descname">unfreeze</code><span class="sig-paren">(</span><em class="sig-param">weights: Set[str] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#NonTrainableNM.unfreeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.NonTrainableNM.unfreeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Unfreeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to unfreeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are unfreezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nemo.backends.pytorch.nm.TrainableNM">
<em class="property">class </em><code class="sig-prename descclassname">nemo.backends.pytorch.nm.</code><code class="sig-name descname">TrainableNM</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_modules.NeuralModule" title="nemo.core.neural_modules.NeuralModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_modules.NeuralModule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>A helper Base class for NeuralModule’s based on Pytorch’s nn.Module.</p>
<p>If you have a Pytorch class which derives from nn.Module you can
covert it into a NeuralModule, by replacing inheriting from this class
instead</p>
<p>Your constructor then should look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">TrainableNM</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">_input_ports</span> <span class="o">=</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">_output_ports</span> <span class="o">=</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
  <span class="o">....</span> <span class="c1"># you code</span>
</pre></div>
</div>
<p>Then make sure that your forward(..) method accepts arguments named like
input ports.</p>
<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM.freeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to freeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are freezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.get_weights">
<code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM.get_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns NeuralModule’s weights copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary of name -&gt; (weights, trainable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.num_weights">
<em class="property">property </em><code class="sig-name descname">num_weights</code><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.num_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of module’s weights</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.restore_from">
<code class="sig-name descname">restore_from</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">local_rank=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM.restore_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.restore_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore module’s state from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to where to restore from.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.save_to">
<code class="sig-name descname">save_to</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM.save_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.save_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Save module state to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to while where to save.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.set_weights">
<code class="sig-name descname">set_weights</code><span class="sig-paren">(</span><em class="sig-param">name2weight</em>, <em class="sig-param">name2name_and_transform=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM.set_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.set_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets weight from given values. For every named weight in
name2weight,
if weight with the same name is found in the model, it will be set to
found value.</p>
<p>WARNING: This will NOT tie weights. It will copy values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weight</span></code>.
Then, if <code class="docutils literal notranslate"><span class="pre">name2name_and_transform['X']=('Y',</span>
<span class="pre">WeightShareTransform.TRANSPOSE)</span></code>
and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is 5x3 weight and <code class="docutils literal notranslate"><span class="pre">name2weight['Y']=Y.</span> <span class="pre">Then:</span>
<span class="pre">``object1.set_weights(name2weight,</span> <span class="pre">name2name_and_transform)</span></code> will
set object1.X=transpose(Y).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name2weight</strong> (<em>dict</em>) – dictionary of name to (weight, trainable).</p></li>
<li><p><strong>this is output of get_weights method.</strong> (<em>Typically</em>) – </p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.tie_weights_with">
<code class="sig-name descname">tie_weights_with</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">weight_names</em>, <em class="sig-param">name2name_and_transform=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM.tie_weights_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.tie_weights_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Ties weights between self and module. For every weight name in
weight_names, if weight with the same name is found in self, it will
be tied
with a same weight from <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<p>WARNING: Once weights are tied, updates to one weights’s weights
will affect
other module’s weights.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weights</span></code>
and <code class="docutils literal notranslate"><span class="pre">object2.Y</span> <span class="pre">=</span> <span class="pre">5x3</span> <span class="pre">weights</span></code>. Then these weights can be tied like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">object1</span><span class="o">.</span><span class="n">tie_weights_with</span><span class="p">(</span><span class="n">object2</span><span class="p">,</span> <span class="n">weight_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span>
<span class="n">name2name_and_transform</span> <span class="o">=</span>
<span class="p">{</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">WeightShareTransform</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">)})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – with which module to tie weights</p></li>
<li><p><strong>weight_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – list of self weights’ names</p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.nm.TrainableNM.unfreeze">
<code class="sig-name descname">unfreeze</code><span class="sig-paren">(</span><em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/nm.html#TrainableNM.unfreeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.nm.TrainableNM.unfreeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Unfreeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to unfreeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are unfreezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nemo.backends.pytorch.module_wrapper">
<span id="id3"></span><h2>可训练模块的封装器<a class="headerlink" href="#module-nemo.backends.pytorch.module_wrapper" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper">
<em class="property">class </em><code class="sig-prename descclassname">nemo.backends.pytorch.module_wrapper.</code><code class="sig-name descname">TrainableNeuralModuleWrapper</code><span class="sig-paren">(</span><em class="sig-param">pt_nn_module</em>, <em class="sig-param">input_ports_dict</em>, <em class="sig-param">output_ports_dict</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nemo.core.neural_modules.NeuralModule" title="nemo.core.neural_modules.NeuralModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nemo.core.neural_modules.NeuralModule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>This class wraps an instance of Pytorch’s nn.Module and
returns NeuralModule’s instance.</p>
<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.create_ports">
<em class="property">static </em><code class="sig-name descname">create_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.create_ports"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.create_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Ports are passed in the constructor and handled there</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the module in evaluation mode.</p>
<p>This has any effect only on certain modules. See documentations of
particular modules for details of their behaviors in training/evaluation
mode, if they are affected, e.g. <code class="xref py py-class docutils literal notranslate"><span class="pre">Dropout</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BatchNorm</span></code>,
etc.</p>
<p>This is equivalent with <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.train(False)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>self</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Module</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.freeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to freeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are freezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.get_weights">
<code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.get_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns NeuralModule’s weights copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary of name -&gt; (weights, trainable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.named_parameters">
<code class="sig-name descname">named_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.named_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.named_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over module parameters, yielding both the
name of the parameter as well as the parameter itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prefix</strong> (<em>str</em>) – prefix to prepend to all parameter names.</p></li>
<li><p><strong>recurse</strong> (<em>bool</em>) – if True, then yields parameters of this module
and all submodules. Otherwise, yields only parameters that
are direct members of this module.</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>(string, Parameter)</em> – Tuple containing the name and parameter</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="nb">print</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.num_weights">
<em class="property">property </em><code class="sig-name descname">num_weights</code><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.num_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of module’s weights</p>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.parameters">
<code class="sig-name descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over module parameters.</p>
<p>This is typically passed to an optimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>recurse</strong> (<em>bool</em>) – if True, then yields parameters of this module
and all submodules. Otherwise, yields only parameters that
are direct members of this module.</p>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>Parameter</em> – module parameter</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">param</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
<span class="go">&lt;class &#39;torch.FloatTensor&#39;&gt; (20L,)</span>
<span class="go">&lt;class &#39;torch.FloatTensor&#39;&gt; (20L, 1L, 5L, 5L)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.restore_from">
<code class="sig-name descname">restore_from</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.restore_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.restore_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore module’s state from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to where to restore from.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.save_to">
<code class="sig-name descname">save_to</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.save_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.save_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Save module state to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – path to while where to save.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.set_weights">
<code class="sig-name descname">set_weights</code><span class="sig-paren">(</span><em class="sig-param">name2weight</em>, <em class="sig-param">name2name_and_transform=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.set_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.set_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets weight from given values. For every named weight in
name2weight,
if weight with the same name is found in the model, it will be set to
found value.</p>
<p>WARNING: This will NOT tie weights. It will copy values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weight</span></code>.
Then, if <code class="docutils literal notranslate"><span class="pre">name2name_and_transform['X']=('Y',</span>
<span class="pre">WeightShareTransform.TRANSPOSE)</span></code>
and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is 5x3 weight and <code class="docutils literal notranslate"><span class="pre">name2weight['Y']=Y.</span> <span class="pre">Then:</span>
<span class="pre">``object1.set_weights(name2weight,</span> <span class="pre">name2name_and_transform)</span></code> will
set object1.X=transpose(Y).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name2weight</strong> (<em>dict</em>) – dictionary of name to (weight, trainable).</p></li>
<li><p><strong>this is output of get_weights method.</strong> (<em>Typically</em>) – </p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.tie_weights_with">
<code class="sig-name descname">tie_weights_with</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">weight_names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.tie_weights_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.tie_weights_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Ties weights between self and module. For every weight name in
weight_names, if weight with the same name is found in self, it will
be tied
with a same weight from <code class="docutils literal notranslate"><span class="pre">module</span></code>.</p>
<p>WARNING: Once weights are tied, updates to one weights’s weights
will affect
other module’s weights.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name2name_and_transform</span></code> is provided then if will set weights
using
name mapping and transform. For example, suppose <code class="docutils literal notranslate"><span class="pre">objec1.X</span> <span class="pre">=</span> <span class="pre">3x5</span>
<span class="pre">weights</span></code>
and <code class="docutils literal notranslate"><span class="pre">object2.Y</span> <span class="pre">=</span> <span class="pre">5x3</span> <span class="pre">weights</span></code>. Then these weights can be tied like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">object1</span><span class="o">.</span><span class="n">tie_weights_with</span><span class="p">(</span><span class="n">object2</span><span class="p">,</span> <span class="n">weight_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span>
<span class="n">name2name_and_transform</span> <span class="o">=</span>
<span class="p">{</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">WeightShareTransform</span><span class="o">.</span><span class="n">TRANSPOSE</span><span class="p">)})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – with which module to tie weights</p></li>
<li><p><strong>weight_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – list of self weights’ names</p></li>
<li><p><strong>name2name_and_transform</strong> – mapping from name -&gt; (name, transform)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the module in training mode.</p>
<p>This has any effect only on certain modules. See documentations of
particular modules for details of their behaviors in training/evaluation
mode, if they are affected, e.g. <code class="xref py py-class docutils literal notranslate"><span class="pre">Dropout</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BatchNorm</span></code>,
etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode</strong> (<em>bool</em>) – whether to set training mode (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or evaluation
mode (<code class="docutils literal notranslate"><span class="pre">False</span></code>). Default: <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Module</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.unfreeze">
<code class="sig-name descname">unfreeze</code><span class="sig-paren">(</span><em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nemo/backends/pytorch/module_wrapper.html#TrainableNeuralModuleWrapper.unfreeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nemo.backends.pytorch.module_wrapper.TrainableNeuralModuleWrapper.unfreeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Unfreeze weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>set</em>) – set of weight names to unfreeze</p></li>
<li><p><strong>None</strong><strong>, </strong><strong>all weights are unfreezed.</strong> (<em>If</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="modules.html" class="btn btn-neutral float-left" title="NeMo API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018-2019, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>